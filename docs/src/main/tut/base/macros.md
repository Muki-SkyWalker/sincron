---
layout: page
title: Macro Utilities
permalink: /tut/base/macros.html
---

Sincron exposes utilities for inlining function arguments in macros,
in a way that's compatible with both Scala 2.10 and 2.11.

Suppose we've got this type:

```tut:silent
case class Box[T](value: T) {
  def map[U](f: T => U): Box[U] = ???
}
```

In order to build a `map` macro that inlines the given function `f`, 
we can do this:

```scala
// Hack to support both Scala 2.10 and Scala 2.11
import org.sincron.macros.compat._
import org.sincron.macros.{SyntaxUtil, InlineUtil}
import scala.language.experimental.macros

case class Box[T](value: T) {
  def map[U](f: T => U): Box[U] = macro Box.mapMacro[T,U]
}

object Box {
  /** Macro implementation for [[Box.map]] */
  def mapMacro[T : c.WeakTypeTag, U : c.WeakTypeTag]
    (c: Context { type PrefixType = Box[T] })
    (f: c.Expr[T => U]): c.Expr[Box[U]] = {

    import c.universe._
    val util = SyntaxUtil[c.type](c)
    val selfExpr: c.Expr[Box[T]] = c.prefix

    /*
     * If our arguments are all "clean" (anonymous functions or simple
     * identifiers) then we can go ahead and just inline them directly.
     *
     * If one or more of our arguments are "dirty" (something more
     * complex than an anonymous function or simple identifier) then
     * we will go ahead and bind each argument to a val just to be
     * safe.
     */
    val tree =
      if (util.isClean(selfExpr, f)) {
        q"""
        Example.Box($f(${selfExpr.tree}.value))
        """
      }
      else {
        val self = util.name("self")
        val fn = util.name("fn")

        q"""
        val $self = $selfExpr
        val $fn = $f
        Example.Box($fn($self.value))
        """
      }

    new InlineUtil[c.type](c).inlineAndReset[Box[U]](tree)
  }
}
```

And now when you do this:

```scala
val box = Example.Box(1)
box.map(_ + 1)
```

The given anonymous function, that increments the given number, gets inlined. 
As evidence you can use the `javap` utility to check the generated code (and it's a good
idea to do so). The generated bytecode for the above would be more or less:

```
 0: new           #9                  // class Example$Box
 3: dup
 4: iconst_1
 5: invokestatic  #15                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
 8: invokespecial #19                 // Method Example$Box."<init>":(Ljava/lang/Object;)V
11: astore_1
12: new           #9                  // class Example$Box
15: dup
16: aload_1
17: invokevirtual #23                 // Method Example$Box.value:()Ljava/lang/Object;
20: invokestatic  #27                 // Method scala/runtime/BoxesRunTime.unboxToInt:(Ljava/lang/Object;)I
23: iconst_1
24: iadd
25: invokestatic  #15                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
28: invokespecial #19                 // Method Example$Box."<init>":(Ljava/lang/Object;)V
31: areturn
```

If you'll take a look in the above `javap` dump, you'll see `iadd` on line 24, instead
of seeing some anonymous function being applied.